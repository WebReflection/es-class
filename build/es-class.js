/*! (C) Andrea Giammarchi - MIT Style License */
var Class=Class||function(Object){"use strict";var CONSTRUCTOR="constructor",EXTENDS="extends",IMPLEMENTS="implements",INIT="init",PROTOTYPE="prototype",STATIC="static",SUPER="super",TO_STRING="toString",VALUE="value",WITH="with",PROTO="__proto__",nonEnumerables=["hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString",TO_STRING,"valueOf"],ObjectPrototype=Object[PROTOTYPE],hOP=ObjectPrototype[nonEnumerables[0]],toString=ObjectPrototype[TO_STRING],propertyIsEnumerable=ObjectPrototype[nonEnumerables[2]]||function(p){for(var k in this)if(p===k)return hOP.call(this,p);return false},hasIEEnumerableBug=!propertyIsEnumerable.call({toString:0},TO_STRING),create=Object.create||function(proto){var isInstance=this instanceof create;create[PROTOTYPE]=isInstance?createPrototype:proto||ObjectPrototype;return isInstance?this:new create},createPrototype=create[PROTOTYPE],defineProperty=Object.defineProperty,gOPD=Object.getOwnPropertyDescriptor,gOPN=Object.getOwnPropertyNames||function(object){var names=[],i,key;for(key in object){if(hOP.call(object,key)){names.push(key)}}if(hasIEEnumerableBug){for(i=0;i<nonEnumerables.length;i++){key=nonEnumerables[i];if(hOP.call(object,key)){names.push(key)}}}return names},gOPS=Object.getOwnPropertySymbols||function(){return[]},getPrototypeOf=Object.getPrototypeOf,gPO=getPrototypeOf||function(o){return o[PROTO]||null},oK=function(o){return gOPN(o).concat(gOPS(o))},isArray=Array.isArray||function(a){return toString.call(a)==="[object Array]"},nativeFunctionOPN=gOPN(function(){}).concat("arguments"),indexOf=nativeFunctionOPN.indexOf||function(v){for(var i=this.length;i--&&this[i]!==v;){}return i},isClassDescriptor={value:true},trustSuper=(""+function(){this["super"]()}).indexOf(SUPER)<0?function(){return true}:function(method){var str=""+method,i=str.indexOf(SUPER);return i<0?false:isBoundary(str.charCodeAt(i-1))&&isBoundary(str.charCodeAt(i+5))};try{defineProperty({},"{}",{})}catch(o_O){if("__defineGetter__"in{}){defineProperty=function(object,name,descriptor){if(hOP.call(descriptor,VALUE)){object[name]=descriptor[VALUE]}else{if(hOP.call(descriptor,"get")){object.__defineGetter__(name,descriptor.get)}if(hOP.call(descriptor,"set")){object.__defineSetter__(name,descriptor.set)}}return object};gOPD=function(object,key){var get=object.__lookupGetter__(key),set=object.__lookupSetter__(key),descriptor={};if(get||set){if(get){descriptor.get=get}if(set){descriptor.set=set}}else{descriptor[VALUE]=object[key]}return descriptor}}else{defineProperty=function(object,name,descriptor){object[name]=descriptor[VALUE];return object};gOPD=function(object,key){return{value:object[key]}}}}function addMixins(mixins,target,inherits,isNOTExtendingNative){for(var source,init=[],i=0;i<mixins.length;i++){source=transformMixin(mixins[i]);if(hOP.call(source,INIT)){init.push(source[INIT])}copyOwn(source,target,inherits,false,false,isNOTExtendingNative)}return init}function copyDeep(source){for(var key,descriptor,value,target=create(gPO(source)),names=oK(source),i=0;i<names.length;i++){key=names[i];descriptor=gOPD(source,key);if(hOP.call(descriptor,VALUE)){copyValueIfObject(descriptor,copyDeep)}defineProperty(target,key,descriptor)}return target}function copyMerged(source,target){for(var key,descriptor,value,tvalue,names=oK(source),i=0;i<names.length;i++){key=names[i];descriptor=gOPD(source,key);if(hOP.call(target,key)){if(hOP.call(descriptor,VALUE)){value=descriptor[VALUE];if(isObject(value)){descriptor=gOPD(target,key);if(hOP.call(descriptor,VALUE)){tvalue=descriptor[VALUE];if(isObject(tvalue)){copyMerged(value,tvalue)}}}}}else{if(hOP.call(descriptor,VALUE)){copyValueIfObject(descriptor,copyDeep)}defineProperty(target,key,descriptor)}}}function copyOwn(source,target,inherits,publicStatic,allowInit,isNOTExtendingNative){for(var key,noFunctionCheck=typeof source!=="function",names=oK(source),i=0;i<names.length;i++){key=names[i];if((noFunctionCheck||indexOf.call(nativeFunctionOPN,key)<0)&&isNotASpecialKey(key,allowInit)){if(hOP.call(target,key)){warn("duplicated: "+key.toString())}setProperty(inherits,target,key,gOPD(source,key),publicStatic,isNOTExtendingNative)}}}function copyValueIfObject(where,how){var what=where[VALUE];if(isObject(what)){where[VALUE]=how(what)}}function createConstructor(hasParentPrototype,parent){var Class=function Class(){};return hasParentPrototype&&""+parent!==""+Class?function Class(){return parent.apply(this,arguments)}:Class}function define(target,key,value,publicStatic){var configurable=isConfigurable(key,publicStatic);defineProperty(target,key,{enumerable:false,configurable:configurable,writable:configurable,value:value})}function isBoundary(code){return code?(code<65||90<code)&&(code<97||122<code)&&code!==95:true}function isConfigurable(key,publicStatic){return publicStatic?!isPublicStatic(key):true}function isNotASpecialKey(key,allowInit){return key!==CONSTRUCTOR&&key!==EXTENDS&&key!==IMPLEMENTS&&key!==PROTOTYPE&&key!==STATIC&&key!==SUPER&&key!==WITH&&(allowInit||key!==INIT)}function isObject(value){return value!=null&&typeof value==="object"}function isPublicStatic(key){for(var c,i=0;i<key.length;i++){c=key.charCodeAt(i);if((c<65||90<c)&&c!==95){return false}}return true}function transformMixin(trait){if(isObject(trait))return trait;else{var i,key,keys,object,proto;if(trait.isClass){if(trait.length){warn((trait.name||"Class")+" should not expect arguments")}for(object={init:trait},proto=trait.prototype;proto&&proto!==Object.prototype;proto=gPO(proto)){for(i=0,keys=oK(proto);i<keys.length;i++){key=keys[i];if(isNotASpecialKey(key,false)&&!hOP.call(object,key)){defineProperty(object,key,gOPD(proto,key))}}}}else{for(i=0,object={},proto=trait({}),keys=oK(proto);i<keys.length;i++){key=keys[i];if(key!==INIT){if(~key.toString().indexOf("mixin:init")&&isArray(proto[key])){object.init=proto[key][0]}else{defineProperty(object,key,gOPD(proto,key))}}}}return object}}function setProperty(inherits,target,key,descriptor,publicStatic,isNOTExtendingNative){var hasValue=hOP.call(descriptor,VALUE),configurable,value;if(publicStatic){if(hOP.call(target,key)){if(inherits&&isObject(target[key])&&isObject(inherits[CONSTRUCTOR][key])){copyMerged(inherits[CONSTRUCTOR][key],target[key])}return}else if(hasValue){copyValueIfObject(descriptor,copyDeep)}}else if(hasValue){value=descriptor[VALUE];if(typeof value==="function"&&trustSuper(value)){descriptor[VALUE]=wrap(inherits,key,value,publicStatic)}}else if(isNOTExtendingNative){wrapGetOrSet(inherits,key,descriptor,"get");wrapGetOrSet(inherits,key,descriptor,"set")}configurable=isConfigurable(key,publicStatic);descriptor.enumerable=false;descriptor.configurable=configurable;if(hasValue){descriptor.writable=configurable}defineProperty(target,key,descriptor)}function verifyImplementations(interfaces,target){for(var current,key,i=0;i<interfaces.length;i++){current=interfaces[i];for(key in current){if(hOP.call(current,key)&&!hOP.call(target,key)){warn(key.toString()+" is not implemented")}}}}function warn(message){try{console.warn(message)}catch(meh){}}function wrap(inherits,key,method,publicStatic){return function(){if(!hOP.call(this,SUPER)){define(this,SUPER,null,publicStatic)}var previous=this[SUPER],current=this[SUPER]=inherits[key],result=method.apply(this,arguments);this[SUPER]=previous;return result}}function wrapGetOrSet(inherits,key,descriptor,gs,publicStatic){if(hOP.call(descriptor,gs)&&trustSuper(descriptor[gs])){descriptor[gs]=wrap(gOPD(inherits,key),gs,descriptor[gs],publicStatic)}}return function(description){var hasConstructor=hOP.call(description,CONSTRUCTOR),hasParent=hOP.call(description,EXTENDS),parent=hasParent&&description[EXTENDS],hasParentPrototype=hasParent&&typeof parent==="function",inherits=hasParentPrototype?parent[PROTOTYPE]:parent,constructor=hasConstructor?description[CONSTRUCTOR]:createConstructor(hasParentPrototype,parent),hasSuper=hasParent&&hasConstructor&&trustSuper(constructor),prototype=hasParent?create(inherits):constructor[PROTOTYPE],isNOTExtendingNative=toString.call(inherits).indexOf(" GObject_")<0,mixins,length;if(hasSuper&&isNOTExtendingNative){constructor=wrap(inherits,CONSTRUCTOR,constructor,false)}if(hOP.call(description,WITH)){mixins=addMixins([].concat(description[WITH]),prototype,inherits,isNOTExtendingNative);length=mixins.length;if(length){constructor=function(parent){return function(){var i=0;while(i<length)mixins[i++].call(this);return parent.apply(this,arguments)}}(constructor);constructor[PROTOTYPE]=prototype}}if(hOP.call(description,STATIC)){copyOwn(description[STATIC],constructor,inherits,true,true,isNOTExtendingNative)}if(hasParent){if(parent!==inherits){copyOwn(parent,constructor,inherits,true,true,isNOTExtendingNative)}constructor[PROTOTYPE]=prototype}if(prototype[CONSTRUCTOR]!==constructor){define(prototype,CONSTRUCTOR,constructor,false)}copyOwn(description,prototype,inherits,false,true,isNOTExtendingNative);if(hOP.call(description,IMPLEMENTS)){verifyImplementations([].concat(description[IMPLEMENTS]),prototype)}if(hasParent&&!getPrototypeOf){define(prototype,PROTO,inherits,false)}return defineProperty(constructor,"isClass",isClassDescriptor)}}(Object);
